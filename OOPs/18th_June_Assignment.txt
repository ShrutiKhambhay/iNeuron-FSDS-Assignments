1. What is the role of the 'else' block in a try-except statement? Provide an example
scenario where it would be useful.
Ans:
The else block in a try-except statement is an optional block of code that is executed if no exceptions are raised in the try block. This means that if no exceptions occur, the code in the else block is executed.
Eg:
try:
  print("Hello")
except:
  print("Something went wrong")
else:
  print("Nothing went wrong")
  
2. Can a try-except block be nested inside another try-except block? Explain with an
example.
Ans:
Yes. 
We can have nested try-except blocks in Python. In this case, if an exception is raised in the nested try block, the nested except block is used to handle it. In case the nested except is not able to handle it, the outer except blocks are used to handle the exception
Eg:
try:
   print("outer try block")
   try:
       print("Inner try block")
   except ZeroDivisionError:
       print("Inner except block")
except:
   print("outer except block")
   
3. How can you create a custom exception class in Python? Provide an example that
demonstrates its usage.
Ans:
In Python, you can create a custom exception by defining a new class that inherits from the built-in `Exception` class or one of its subclasses. To raise the custom exception, you can use the `raise` keyword followed by an instance of your custom exception class.
Eg:
class CustomError(Exception):
    pass
raise CustomError("Example of Custom Exceptions in Python")
Output: CustomError: Example of Custom Exceptions in Python

4. What are some common exceptions that are built-in to Python?
Ans:
In Python, all exceptions must be instances of a class that derives from BaseException . In a try statement with an except clause that mentions a particular class, that clause also handles any exception classes derived from that class (but not exception classes from which it is derived).

5. What is logging in Python, and why is it important in software development?
Ans:
Logging is a way to store information about your script and track events that occur. When writing any complex script in Python, logging is essential for debugging software as you develop it. Without logging, finding the source of a problem in your code may be extremely time consuming.

6. Explain the purpose of log levels in Python logging and provide examples of when
each log level would be appropriate.
Ans:
A logging level is a way of classifying the entries in your log file in terms of urgency.

7. What are log formatters in Python logging, and how can you customise the log
message format using formatters?
Ans:
Loggers expose the interface that application code directly uses. Handlers send the log records (created by loggers) to the appropriate destination. Filters provide a finer grained facility for determining which log records to output. Formatters specify the layout of log records in the final output.

8.How can you set up logging to capture log messages from multiple modules or classes in a Python application?
Ans:
Create and configure the logger. It can have several parameters. But importantly, pass the name of the file in which you want to record the events.
Here the format of the logger can also be set. By default, the file works in append mode but we can change that to write mode if required.
Also, the level of the logger can be set which acts as the threshold for tracking based on the numeric values assigned to each level. 
There are several attributes that can be passed as parameters.
The list of all those parameters is given in Python Library. The user can choose the required attribute according to the requirement.
After that, create an object and use the various methods as shown in the example.

9. What is the difference between the logging and print statements in Python? When
should you use logging over print statements in a real-world application?
Ans:
print will just print the text to console. console. log() actually records it and we can use it for many purposes like email it for bug report.
If your code is being imported by other python tools or scripts, it's not practical to print something to stdout using print because the user won't know where these messages are coming from.

10. Write a Python program that logs a message to a file named "app.log" with the
following requirements:
● The log message should be "Hello, World!"
● The log level should be set to "INFO."
● The log file should append new log entries without overwriting previous ones.
Ans: 
import logging
logging.basicConfig(
    filename='app.log',
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logging.info("Hello, World!")

11. Create a Python program that logs an error message to the console and a file named
"errors.log" if an exception occurs during the program's execution. The error
message should include the exception type and a timestamp.
def main():
    logging.basicConfig(
        level=logging.ERROR,
        format='%(asctime)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )

    try:
        result = 1 / 0
    except Exception as e:
        print("An exception occurred:", e)
        logging.error(f"Exception occurred: {type(e)._name_} - {e}")
        logging.error(traceback.format_exc())
